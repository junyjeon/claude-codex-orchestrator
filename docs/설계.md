# claude-codex-orchestrator 설계 문서

## 프로젝트 개요

Claude Code가 코드 작성 작업을 Codex(GPT-5)에게 위임할 수 있게 만든 MCP 서버다.

왜 Codex를 쓰는가? 두 가지 이유가 있다. Codex는 GPT-5 기반으로 코드 생성에 특화되어 있다. Claude Code는 복잡한 코드 작성을 Codex에게 맡기면서 자신의 컨텍스트를 절약할 수 있다.

역할 분담은 명확하다. Claude Code는 전체 워크플로우를 관리하고 언제 Codex를 쓸지 결정한다. Codex는 실제 코드를 생성한다. MCP 서버는 둘을 연결하는 다리로 Codex CLI 실행만 담당한다.

```
패키지: @junyjeon/claude-codex-orchestrator
버전: v0.2.0
배포: 2025-11-11
설치: npm install -g @junyjeon/claude-codex-orchestrator
```

### 전제 조건

**Codex CLI 로그인 필요**:
```bash
codex login
# OpenAI 계정 인증
```

**Claude Code MCP 설정**:
```json
// ~/.claude.json
{
  "mcpServers": {
    "codex": {
      "command": "claude-codex-orchestrator"
    }
  }
}
```

---

## 아키텍처

시스템은 3계층으로 구성된다.

```
┌─────────────────────────────────────┐
│       Claude Code (Client)          │
│   - 워크플로우 관리                    │
│   - Codex 호출 시점 결정               │
│   - 컨텍스트 절약                      │
└──────────────┬──────────────────────┘
               │ MCP Protocol
               │ (stdio/JSON-RPC)
┌──────────────▼──────────────────────┐
│    claude-codex-orchestrator        │
│   - MCP Server                      │
│   - generate_code 도구 제공          │
│   - Codex CLI 실행 래퍼               │
└──────────────┬──────────────────────┘
               │ spawn + stdin pipe
               │ (command injection 방지)
┌──────────────▼──────────────────────┐
│         Codex CLI (GPT-5)           │
│   - 실제 코드 생성                     │
│   - stdin에서 프롬프트 읽기            │
│   - stdout으로 코드 출력              │
└─────────────────────────────────────┘
```

통신 방식은 각 계층마다 다르다. Claude Code와 MCP 서버는 stdio를 통해 JSON-RPC 메시지를 주고받는다. MCP 서버와 Codex CLI는 spawn으로 프로세스를 실행하고 stdin/stdout으로 데이터를 전달한다. 쉘을 거치지 않기 때문에 command injection이 원천적으로 불가능하다.

파일 구조는 4개로 단순하다. types/index.ts에 타입 정의, codex.ts에 Codex CLI 래퍼, server.ts에 MCP 서버, index.ts에 진입점과 환경변수 검증이 있다.

---

## 실행 흐름

### 1. 도구 등록

MCP 서버가 시작되면 generate_code 도구를 등록한다.

```json
{
  "tools": [{
    "name": "generate_code",
    "description": "Generate code using Codex CLI (GPT-5)",
    "inputSchema": {
      "type": "object",
      "properties": {
        "prompt": { "type": "string" }
      },
      "required": ["prompt"]
    }
  }]
}
```

### 2. 코드 생성 요청

Claude Code가 Codex에게 코드 작성을 맡기려고 할 때 generate_code 도구를 호출한다.

```json
{
  "method": "tools/call",
  "params": {
    "name": "generate_code",
    "arguments": {
      "prompt": "Write a Rust function that calculates fibonacci numbers"
    }
  }
}
```

### 3. Codex CLI 실행

MCP 서버가 spawn으로 Codex를 실행한다.

```typescript
const child = spawn('codex', ['exec', '-'], {
  stdio: ['pipe', 'pipe', 'pipe'],
});
child.stdin.write(prompt);
child.stdin.end();
```

stdin으로 프롬프트를 전달한다. 인자로 전달하지 않기 때문에 이스케이프가 필요 없다.

### 4. 코드 수집

Codex가 stdout으로 코드를 출력한다. MCP 서버가 실시간으로 수집하면서 크기를 체크한다. 1MB를 넘으면 프로세스를 종료하고 에러를 반환한다.

타임아웃은 기본 30초다. 넘으면 SIGTERM을 보내고 5초 후에도 안 끝나면 SIGKILL로 강제 종료한다.

### 5. 결과 반환

생성된 코드를 코드 블록으로 감싸서 Claude Code에 반환한다.

```json
{
  "content": [{
    "type": "text",
    "text": "```rust\nfn fibonacci(n: u64) -> u64 {\n    ...\n}\n```"
  }]
}
```

### 에러 처리

8가지 에러 타입이 있다.

- **NOT_FOUND**: Codex CLI 미설치
- **PERMISSION_DENIED**: 실행 권한 없음
- **TIMEOUT**: 30초 초과
- **OUTPUT_TOO_LARGE**: 1MB 초과
- **AUTHENTICATION_FAILED**: 인증 실패
- **EXECUTION_FAILED**: 실행 실패
- **STDIN_WRITE_FAILED**: stdin 쓰기 실패
- **UNKNOWN**: 알 수 없는 에러

각 에러는 code, message, details를 포함한다. Claude Code는 에러 타입에 따라 사용자에게 적절한 안내를 할 수 있다.

---

## 기술 스택

**런타임:**
- Node.js ≥20.0.0
- TypeScript 5.8.3
- Vite 6.3.5 (빌드 1.97초)

**의존성:**
- @modelcontextprotocol/sdk 1.11.4
- zod 3.24.4
- dotenv 16.5.0

**개발도구:**
- Biome 1.9.4 (린팅 + 포매팅)
- Vitest 3.1.3

**빌드 결과:**
- 번들: 10.87KB
- 전체: 37.9KB (타입 선언 + 소스맵)
- 압축: 10.3KB

Vite는 Webpack보다 10배 빠르다. Biome은 ESLint와 Prettier를 대체한다. Vitest는 Vite 환경과 동일해서 설정을 재사용한다.

---

## 품질 보증

9단계 검증 프로세스를 거쳤다.

빌드 출력물 검증부터 시작한다. Shebang이 #!/usr/bin/env node인지 확인한다. 실행 권한이 755인지 본다.

로컬 설치를 테스트한다. npm link로 전역 설치하고 의존성 취약점을 확인한다. 0개가 나왔다.

MCP 서버를 직접 실행한다. [Codex MCP Server] Started 메시지가 나오는지 확인한다. stdin/stdout이 제대로 작동하는지 본다.

환경변수 검증을 테스트한다. LOG_LEVEL에 debug, info, warn, error를 넣어본다. 무효한 값은 기본값(info)으로 폴백하는지 확인한다. CODEX_TIMEOUT도 1000-300000ms 범위를 테스트한다. 범위 밖 값은 기본값(30000ms)으로 폴백한다.

통합 테스트는 실제 Codex CLI를 호출한다. "Write a simple hello world function"을 요청해서 코드가 제대로 생성되는지 확인한다.

타입 정의 파일이 dist/index.d.ts에 생성됐는지 확인한다. npm 패키지에 포함돼서 사용자가 TypeScript 타입 힌트를 받을 수 있다.

문서는 4개 한글 파일과 영어 README로 구성했다. 설계.md는 통합 문서(15분), 구조.md는 파일 구조(3분), 흐름.md는 실행 플로우(2분), 배포.md는 설치 가이드(5분). CHANGELOG.md는 Keep a Changelog 형식으로 버전별 변경사항을 기록한다.

결과는 모든 테스트 통과다. 9개 중 9개가 성공했다. 보안 취약점 0개, 타입 커버리지 100%, 코드 346줄에 번들 10.87KB로 핵심 기능을 구현했다.
